# -*- coding: utf-8 -*-
"""semana3_ADA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EEuTYNjk_OAJKA45MOsxjDi7yaGHXNVd

**Master Theorem**

**T(n) = a*T(n/b) + f(n)**

n = tamaño de la entrada 

a = número de subproblemas en la recursividad (veces que se llama a si misma )

n / b = tamaño de cada subproblema. Se asumen todos los subproblemas tener el mismo tamaño. (como se divide la fraccion del problema)

f (n) = costo del trabajo realizado fuera de la llamada recursiva, que incluye el costo de dividir el problema y costo de fusionar las soluciones.

Aquí, a ≥ 1 y b> 1 son constantes, y f (n) es una función asintóticamente positiva.

1. If f(n) = O(nlogb a-ϵ), then T(n) = Θ(nlogb a).

2. If f(n) = Θ(nlogb a), then T(n) = Θ(nlogb a * log n).

3. If f(n) = Ω(nlogb a+ϵ), then T(n) = Θ(f(n)).

ϵ > 0 es una constante
"""

import numpy as np

precios = np.array((10,8,20,50,44,32,5,4,90,73,82,51,17,15,13,28,99,38,69,25,11,9,47,98,77,33,58,24,15,54))
total=0
descuentos = []
for x in precios:
  actual = np.where(precios==x)
  if not x in descuentos:
    for y in precios[actual[0][0]:]:
      actual_y = np.where(precios==y)
      if y != precios[actual[0][0]] and y < x:
        if not y in descuentos:
          descuentos = np.append(descuentos,precios[actual_y[0][0]])
          total = precios[actual[0][0]] + total
          break

print("\nTotal: ", total)

import numpy as np
precios = np.array((10,8,20,50,44,32,5,4,90,73,82,51,17,15,13,28,99,38,69,25,11,9,47,98,77,33,58,24,15,54))
precios=  sorted(precios, reverse=True)
total=0
desc=0;
for pr in precios:
  if desc == 0:
    total = total+pr
    desc = 1
  else:
    desc = 0 

print("Total: " ,total)

"""Punto mas cercanos sin Dividi y venceras."""

import numpy as np
def nearPoints(lista):
  nearP = 0
  for x in lista:
    cont=0
    temp = 0
    for y in lista:
      if x != y:
        result = np.sqrt((x[0] - y[0])**2 + (x[1] - y[1])**2)
        if temp == 0:
          temp = result
          nearP = cont
        if  result < temp:
          temp = result
          nearP = cont
          
      cont = cont + 1
    print("El punto mas cercano de: ")
    print(x)
    print("es: ")
    print(lista[nearP])

nums = [(0,1),(1,6),(2,1),(3,3),(20,4)]
nearPoints(nums)

"""Puntos cercanos con Divide y Venceras"""

import math

def divNearPoints(lista, sl, sr):
  if sl == sr:
    return [lista[sl]]
  if sl+1 == sr:
    return [lista[sl],lista[sr]]
  else:
    dividir = math.ceil((sl + sr) / 2)
    l1 = divNearPoints(lista, sl, dividir)
    l2 = divNearPoints(lista, dividir+1, sr)
    if l1 != None and l2 != None:
      print("s")
      print(l1+l2)
      nearPoints(l1+l2)
    else:
      if l1 != None:
        print("h")
        print(l1)
        nearPoints(l1)
      else:
        print("f")
        print(l2)
        nearPoints(l2)

nums = [(0,1),(1,2),(2,1),(3,3),(4,4)]
divNearPoints(nums,0,len(nums)-1)

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
plt.ylabel('Puntos Cercanos')
plt.plot([0, 1, 2, 10, 20, 25], [1, 3, 6, 8, 12, 20], 'ro')
plt.axis([0, 25, 0, 25])
plt.show()